{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to horqrux","text":"<p>horqrux is a state vector simulator designed for quantum machine learning written in JAX.</p>"},{"location":"#setup","title":"Setup","text":"<p>To install <code>horqrux</code> , you can go into any virtual environment of your choice and install it normally with <code>pip</code>:</p> <pre><code>pip install horqrux\n</code></pre>"},{"location":"#digital-operations","title":"Digital operations","text":"<p><code>horqrux</code> implements a large selection of both primitive and parametric single to n-qubit, digital quantum gates.</p> <p>Let's have a look at primitive gates first.</p> <pre><code>from horqrux import X, random_state, apply_gate\n\nstate = random_state(2)\nnew_state = apply_gate(state, X(0))\n</code></pre> <p>We can also make any gate controlled, in the case of X, we have to pass the target qubit first!</p> <pre><code>import jax.numpy as jnp\nfrom horqrux import X, product_state, equivalent_state, apply_gate\n\nn_qubits = 2\nstate = product_state('11')\ncontrol = 0\ntarget = 1\n# This is equivalent to performing CNOT(0,1)\nnew_state= apply_gate(state, X(target,control))\nassert jnp.allclose(new_state, product_state('10'))\n</code></pre> <p>When applying parametric gates, we can either pass a numeric value or a parameter name for the parameter as the first argument.</p> <pre><code>import jax.numpy as jnp\nfrom horqrux import RX, random_state, apply_gate\n\ntarget_qubit = 1\nstate = random_state(target_qubit+1)\nparam_value = 1 / 4 * jnp.pi\nnew_state = apply_gate(state, RX(param_value, target_qubit))\n# Parametric horqrux gates also accept parameter names in the form of strings.\n# Simply pass a dictionary of parameter names and values to the 'apply_gate' function\nnew_state = apply_gate(state, RX('theta', target_qubit), {'theta': jnp.pi})\n</code></pre> <p>We can also make any parametric gate controlled simply by passing a control qubit.</p> <pre><code>import jax.numpy as jnp\nfrom horqrux import RX, product_state, apply_gate\n\nn_qubits = 2\ntarget_qubit = 1\ncontrol_qubit = 0\nstate = product_state('11')\nparam_value = 1 / 4 * jnp.pi\nnew_state = apply_gate(state, RX(param_value, target_qubit, control_qubit))\n</code></pre>"},{"location":"#analog-operations","title":"Analog Operations","text":"<p><code>horqrux</code> also allows for global state evolution via the <code>HamiltonianEvolution</code> operation. Note that it expects a hamiltonian and a time evolution parameter passed as <code>numpy</code> or <code>jax.numpy</code> arrays. To build arbitrary Pauli hamiltonians, we recommend using Qadence.</p> <pre><code>from jax.numpy import pi, array, diag, kron, cdouble\nfrom horqrux.analog import HamiltonianEvolution\nfrom horqrux.apply import apply_gate\nfrom horqrux.utils import uniform_state\n\nsigmaz = diag(array([1.0, -1.0], dtype=cdouble))\nHbase = kron(sigmaz, sigmaz)\n\nHamiltonian = kron(Hbase, Hbase)\nn_qubits = 4\nt_evo = pi / 4\nhamevo = HamiltonianEvolution(tuple([i for i in range(n_qubits)]))\npsi = uniform_state(n_qubits)\npsi_star = apply_gate(psi, hamevo, {\"hamiltonian\": Hamiltonian, \"time_evolution\": t_evo})\n</code></pre>"},{"location":"#fitting-a-nonlinear-function-using-adjoint-differentiation","title":"Fitting a nonlinear function using adjoint differentiation","text":"<p>We can now build a fully differentiable variational circuit by simply defining a sequence of gates and a set of initial parameter values we want to optimize. <code>horqrux</code> provides an implementation of adjoint differentiation, which we can use to fit a function using a simple <code>Circuit</code> class.</p> <pre><code>from __future__ import annotations\n\nimport jax\nfrom jax import grad, jit, Array, value_and_grad, vmap\nfrom dataclasses import dataclass\nimport jax.numpy as jnp\nimport optax\nfrom functools import reduce, partial\nfrom operator import add\nfrom typing import Any, Callable\nfrom uuid import uuid4\n\nfrom horqrux.adjoint import adjoint_expectation\nfrom horqrux.circuit import Circuit, hea\nfrom horqrux.primitive import Primitive\nfrom horqrux.parametric import Parametric\nfrom horqrux import Z, RX, RY, NOT, zero_state, apply_gate\n\n\nn_qubits = 5\nn_params = 3\nn_layers = 3\n\n# Lets define a sequence of rotations\n\n#  We need a function to fit and use it to produce training data\nfn = lambda x, degree: .05 * reduce(add, (jnp.cos(i*x) + jnp.sin(i*x) for i in range(degree)), 0)\nx = jnp.linspace(0, 10, 100)\ny = fn(x, 5)\n\n\nclass DQC(Circuit):\n    def __post_init__(self) -&gt; None:\n        self.observable: list[Primitive] = [Z(0)]\n        self.state = zero_state(self.n_qubits)\n\n    @partial(vmap, in_axes=(None, None, 0))\n    def __call__(self, param_values: Array, x: Array) -&gt; Array:\n        param_dict = {name: val for name, val in zip(self.param_names, param_values)}\n        return adjoint_expectation(self.state, self.feature_map + self.ansatz, self.observable, {**param_dict, **{'phi': x}})\n\n\ncirc = DQC(n_qubits=n_qubits, feature_map=[RX('phi', i) for i in range(n_qubits)], ansatz=hea(n_qubits, n_layers))\n# Create random initial values for the parameters\nkey = jax.random.PRNGKey(42)\nparam_vals = jax.random.uniform(key, shape=(circ.n_vparams,))\n# Check the initial predictions using randomly initialized parameters\ny_init = circ(param_vals, x)\n\noptimizer = optax.adam(learning_rate=0.01)\nopt_state = optimizer.init(param_vals)\n\n# Define a loss function\ndef loss_fn(param_vals: Array) -&gt; Array:\n    y_pred = circ(param_vals, x)\n    return jnp.mean(optax.l2_loss(y_pred, y))\n\n\ndef optimize_step(param_vals: Array, opt_state: Array, grads: Array) -&gt; tuple:\n    updates, opt_state = optimizer.update(grads, opt_state)\n    param_vals = optax.apply_updates(param_vals, updates)\n    return param_vals, opt_state\n\n@jit\ndef train_step(i: int, paramvals_w_optstate: tuple\n) -&gt; tuple:\n    param_vals, opt_state = paramvals_w_optstate\n    loss, grads = value_and_grad(loss_fn)(param_vals)\n    param_vals, opt_state = optimize_step(param_vals, opt_state, grads)\n    return param_vals, opt_state\n\n\nn_epochs = 200\nparam_vals, opt_state = jax.lax.fori_loop(0, n_epochs, train_step, (param_vals, opt_state))\ny_final = circ(param_vals, x)\n\n# Lets plot the results\nimport matplotlib.pyplot as plt\nplt.plot(x, y, label=\"truth\")\nplt.plot(x, y_init, label=\"initial\")\nplt.plot(x, y_final, \"--\", label=\"final\", linewidth=3)\nplt.legend()\n</code></pre> 2024-04-16T16:13:40.640417 image/svg+xml Matplotlib v3.8.4, https://matplotlib.org/"},{"location":"#fitting-a-partial-differential-equation-using-dqc","title":"Fitting a partial differential equation using DQC","text":"<p>Finally, we show how DQC can be implemented in <code>horqrux</code> and solve a partial differential equation.</p> <pre><code>from __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom functools import reduce\nfrom itertools import product\nfrom operator import add\nfrom typing import Callable\n\nimport jax\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport optax\nfrom jax import Array, jit, value_and_grad, vmap\nfrom numpy.random import uniform\n\nfrom horqrux.apply import group_by_index\nfrom horqrux.circuit import Circuit, hea\nfrom horqrux import NOT, RX, RY, Z, apply_gate, zero_state\nfrom horqrux.primitive import Primitive\nfrom horqrux.parametric import Parametric\nfrom horqrux.utils import inner\n\nLEARNING_RATE = 0.01\nN_QUBITS = 4\nDEPTH = 3\nVARIABLES = (\"x\", \"y\")\nNUM_VARIABLES = len(VARIABLES)\nX_POS, Y_POS = [i for i in range(NUM_VARIABLES)]\nBATCH_SIZE = 150\nN_EPOCHS = 1000\n\ndef total_magnetization(n_qubits:int) -&gt; Callable:\n    paulis = [Z(i) for i in range(n_qubits)]\n\n    def _total_magnetization(out_state: Array, values: dict[str, Array]) -&gt; Array:\n        projected_state = reduce(\n            add, [apply_gate(out_state, pauli, values) for pauli in paulis]\n        )\n        return inner(out_state, projected_state).real\n    return _total_magnetization\n\n\nclass DQC(Circuit):\n    def __post_init__(self) -&gt; None:\n        self.ansatz = group_by_index(self.ansatz)\n        self.observable = total_magnetization(self.n_qubits)\n        self.state = zero_state(self.n_qubits)\n\n    def __call__(self, param_vals: Array, x: Array, y: Array) -&gt; Array:\n        param_dict = {name: val for name, val in zip(self.param_names, param_vals)}\n        out_state = apply_gate(\n            self.state, self.feature_map + self.ansatz, {**param_dict, **{\"x\": x, \"y\": y}}\n        )\n        return self.observable(out_state, {})\n\n\nfm =  [RX(\"x\", i) for i in range(N_QUBITS // 2)] + [\n            RX(\"y\", i) for i in range(N_QUBITS // 2, N_QUBITS)\n        ]\nansatz = hea(N_QUBITS, DEPTH)\ncirc = DQC(N_QUBITS, fm, ansatz)\n# Create random initial values for the parameters\nkey = jax.random.PRNGKey(42)\nparam_vals = jax.random.uniform(key, shape=(circ.n_vparams,))\n\noptimizer = optax.adam(learning_rate=0.01)\nopt_state = optimizer.init(param_vals)\n\n\ndef loss_fn(param_vals: Array) -&gt; Array:\n    def pde_loss(x: Array, y: Array) -&gt; Array:\n        x = x.reshape(-1, 1)\n        y = y.reshape(-1, 1)\n        left = (jnp.zeros_like(y), y)  # u(0,y)=0\n        right = (jnp.ones_like(y), y)  # u(L,y)=0\n        top = (x, jnp.ones_like(x))  # u(x,H)=0\n        bottom = (x, jnp.zeros_like(x))  # u(x,0)=f(x)\n        terms = jnp.dstack(list(map(jnp.hstack, [left, right, top, bottom])))\n        loss_left, loss_right, loss_top, loss_bottom = vmap(lambda xy: circ(param_vals, xy[:, 0], xy[:, 1]), in_axes=(2,))(\n            terms\n        )\n        loss_bottom -= jnp.sin(jnp.pi * x)\n        hessian = jax.hessian(lambda xy: circ(param_vals, xy[0], xy[1]))(\n            jnp.concatenate(\n                [\n                    x.reshape(\n                        1,\n                    ),\n                    y.reshape(\n                        1,\n                    ),\n                ]\n            )\n        )\n        loss_interior = hessian[X_POS][X_POS] + hessian[Y_POS][Y_POS]  # uxx+uyy=0\n        return jnp.sum(\n            jnp.concatenate(\n                list(\n                    map(\n                        lambda term: jnp.power(term, 2).reshape(-1, 1),\n                        [loss_left, loss_right, loss_top, loss_bottom, loss_interior],\n                    )\n                )\n            )\n        )\n\n    return jnp.mean(vmap(pde_loss, in_axes=(0, 0))(*uniform(0, 1.0, (NUM_VARIABLES, BATCH_SIZE))))\n\n\ndef optimize_step(param_vals: Array, opt_state: Array, grads: dict[str, Array]) -&gt; tuple:\n    updates, opt_state = optimizer.update(grads, opt_state, param_vals)\n    param_vals = optax.apply_updates(param_vals, updates)\n    return param_vals, opt_state\n\n\n@jit\ndef train_step(i: int, paramvals_w_optstate: tuple) -&gt; tuple:\n    param_vals, opt_state = paramvals_w_optstate\n    loss, grads = value_and_grad(loss_fn)(param_vals)\n    return optimize_step(param_vals, opt_state, grads)\n\n\nparam_vals, opt_state = jax.lax.fori_loop(0, N_EPOCHS, train_step, (param_vals, opt_state))\n# compare the solution to known ground truth\nsingle_domain = jnp.linspace(0, 1, num=BATCH_SIZE)\ndomain = jnp.array(list(product(single_domain, single_domain)))\n# analytical solution\nanalytic_sol = (\n    (np.exp(-np.pi * domain[:, 0]) * np.sin(np.pi * domain[:, 1])).reshape(BATCH_SIZE, BATCH_SIZE).T\n)\n# DQC solution\ndqc_sol = vmap(lambda domain: circ(param_vals, domain[0], domain[1]), in_axes=(0,))(\n    domain\n).reshape(BATCH_SIZE, BATCH_SIZE)\n# # plot results\nfig, ax = plt.subplots(1, 2, figsize=(7, 7))\nax[0].imshow(analytic_sol, cmap=\"turbo\")\nax[0].set_xlabel(\"x\")\nax[0].set_ylabel(\"y\")\nax[0].set_title(\"Analytical solution u(x,y)\")\nax[1].imshow(dqc_sol, cmap=\"turbo\")\nax[1].set_xlabel(\"x\")\nax[1].set_ylabel(\"y\")\nax[1].set_title(\"DQC solution u(x,y)\")\n</code></pre> 2024-04-16T16:14:27.346371 image/svg+xml Matplotlib v3.8.4, https://matplotlib.org/"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CONTRIBUTING/","title":"How to Contribute","text":"<p>We're grateful for your interest in participating in horqrux! Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an Issue or Proposing a Feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added to horqrux, feel free to create an issue on horqrux's GitHub issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a Pull Request","text":"<p>We're excited that you're eager to contribute to horqrux! To contribute, fork the <code>main</code> branch of horqrux repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Click the \"Fork\" button at the upper right corner of the repo page to create a new GitHub repo at <code>https://github.com/USERNAME/horqrux</code>, where <code>USERNAME</code> is your GitHub ID. Then, <code>cd</code> into the directory where you want to place your new fork and clone it:</p> <pre><code>git clone https://github.com/USERNAME/horqrux.git\n</code></pre> <p>Next, navigate to your new horqrux fork directory and mark the main horqrux repository as the <code>upstream</code>:</p> <pre><code>git remote add upstream https://github.com/pasqal-io/horqrux.git\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>We recommended to use <code>hatch</code> for managing environments:</p> <p>To develop within horqrux, use: <pre><code>pip install hatch\nhatch -v shell\n</code></pre></p> <p>To run horqrux tests, use:</p> <pre><code>hatch -e tests run test\n</code></pre> <p>If you don't want to use <code>hatch</code>, you can use the environment manager of your choice (e.g. Conda) and execute the following:</p> <pre><code>pip install pytest\n\npip install -e .\npytest\n</code></pre>"},{"location":"CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful Things for your workflow: Linting and Testing","text":"<p>Use <code>pre-commit</code> hooks to make sure that the code is properly linted before pushing a new commit. Make sure that the unit tests and type checks are passing since the merge request will not be accepted if the automatic CI/CD pipeline do not pass.</p> <p>Without <code>hatch</code>:</p> <pre><code>pip install pytest\n\npip install -e .\npip install pre-commit\npre-commit install\npre-commit run --all-files\npytest\n</code></pre> <p>And with <code>hatch</code>:</p> <pre><code>hatch -e tests run pre-commit run --all-files\nhatch -e tests run test\n</code></pre> <p>Make sure your docs build too!</p> <p>With <code>hatch</code>:</p> <pre><code>hatch -e docs run mkdocs build --clean --strict\n</code></pre> <p>Without <code>hatch</code>, <code>pip</code> install those libraries first: \"mkdocs\", \"mkdocs-material\", \"mkdocstrings\", \"mkdocstrings-python\", \"mkdocs-section-index\", \"mkdocs-jupyter\", \"mkdocs-exclude\", \"markdown-exec\"</p> <p>And then:</p> <pre><code> mkdocs build --clean --strict\n</code></pre>"}]}